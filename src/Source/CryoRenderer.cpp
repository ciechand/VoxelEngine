#include "../Headers/CryoMain.hpp"
#include "../Headers/CryoRenderer.hpp"
#include "../Headers/CryoChunk.hpp"
#include "../Headers/CryoUtil.hpp"

RenderController ShaderController;

VoxelColor GlobalColor = Red;

//const int BlockColors[16] = {0x000000, 0xff0000, 0x800000, 0xff0084, 0x9c00ff, 0x000080, 0x0000ff, 0x00baff, 0x00ffcc, 0x00ff30, 0x009900, 0x999900, 0xfcff00, 0xa56900, 0xffa200, 0xff8900};
const glm::vec3 BlockColors[16] = {glm::vec3(255.0f,255.0f,255.0f),glm::vec3(255.0f,0.0f,0.0f),glm::vec3(128.0f,0.0f,0.0f),
									glm::vec3(255.0f,119.0f,173.0f),glm::vec3(255.0f,0.0f,102.0f), glm::vec3(156.0f,0.0f,255.0f),
									glm::vec3(0.0f,0.0f,128.0f),glm::vec3(0.0f,0.0f,255.0f),glm::vec3(0.0f,186.0f,255.0f),
									glm::vec3(0.0f,255.0f,204.0f),glm::vec3(0.0f,255.0f,48.0f),glm::vec3(0.0f,153.0f,0.0f),
									glm::vec3(252.0f,255.0f,0.0f),glm::vec3(165.0f,105.0f,0.0f),glm::vec3(255.0f,204.0f,0.0f),
									glm::vec3(255.0f,137.0f,0.0f)};

//Const Global Array for the different vertexes of a cube. These Can be accessed with the enum CubeVertices.
const glm::vec3 CubeVerts[8] = {
glm::vec3(-HALFSIZE,HALFSIZE,-HALFSIZE),glm::vec3(HALFSIZE,HALFSIZE,-HALFSIZE),
glm::vec3(-HALFSIZE,HALFSIZE, HALFSIZE),glm::vec3(HALFSIZE,HALFSIZE,HALFSIZE),
glm::vec3(-HALFSIZE,-HALFSIZE,-HALFSIZE),glm::vec3(HALFSIZE,-HALFSIZE,-HALFSIZE),
glm::vec3(-HALFSIZE,-HALFSIZE,HALFSIZE),glm::vec3(HALFSIZE,-HALFSIZE,HALFSIZE)
};

//Const GlobaL array for the different directional vectors, these can be accessed with the CubeFace Enum.
const glm::vec3 DirectionVectors[6] = { 
glm::vec3(1.0,0.0,0.0), glm::vec3(-1.0,0.0,0.0),
glm::vec3(0.0,1.0,0.0), glm::vec3(0.0,-1.0,0.0),
glm::vec3(0.0,0.0,1.0), glm::vec3(0.0,0.0,-1.0)
};

//Functions for the Voxel Class
Voxel::Voxel(){
	voxColor = Red;
	position = glm::vec3(0.0f, 0.0f, 0.0f);
	transformMatrices.assign(4,glm::mat4());
}

Voxel::~Voxel(){

	
}

bool Voxel::getActive(){
	return voxActive;	
}

void Voxel::setActive(bool va){
	voxActive = va;
}

glm::vec3 Voxel::getPosition(){
	return position;
}

void Voxel::setPosition(glm::vec3 pos){
	position = pos;
	transformMatrices[TranslateMatrix] = glm::translate(glm::mat4(), pos);
	transformMatrices[CombinedMatrix] = transformMatrices[TranslateMatrix]*transformMatrices[ScaleMatrix]*transformMatrices[RotationMatrix];
}

void Voxel::setScale(unsigned int s){
	transformMatrices[ScaleMatrix] = glm::translate(glm::mat4(), glm::vec3(s,s,s));
	transformMatrices[CombinedMatrix] = transformMatrices[TranslateMatrix]*transformMatrices[ScaleMatrix]*transformMatrices[RotationMatrix];
}

void Voxel::setRotation(float angle, glm::vec3 rot){
	transformMatrices[RotationMatrix] = glm::rotate(glm::mat4(), angle, rot);
	transformMatrices[CombinedMatrix] = transformMatrices[TranslateMatrix]*transformMatrices[ScaleMatrix]*transformMatrices[RotationMatrix];
}

glm::mat4 Voxel::getTMatrix(unsigned int index){
	return transformMatrices[index];
}

bool Voxel::getActiveSide(unsigned int n){
	return activeSides[n];
}

std::vector<bool> Voxel::getActiveSide(){
	return activeSides;
}

void Voxel::setActiveSide(unsigned int s, bool a){
	activeSides[s] = a;
	for(int i=0;i<activeSides.size();i++){
		if(activeSides[i] == true)
			return;
	}
	voxActive = false;
}

void Voxel::setActiveSide(std::vector<bool> s){
	activeSides = s;
}


VoxelColor Voxel::getColor(){
	return voxColor;
}

void Voxel::setColor(VoxelColor vc){
	voxColor = vc;
}

std::vector<float> Voxel::getBrightness(){
	return brightness;
}

float Voxel::getBrightness(unsigned int n){
	return brightness[n];
}

void Voxel::setBrightness(unsigned int n, float c){
	brightness[n] = c;
}

void Voxel::setBrightness(std::vector<float> s){
	brightness = s;
}

int Voxel::getVoxTex(){
	return voxTex;
}

void Voxel::setVoxTex(int t){
	voxTex = t;
}



//Start of MESH Class
Mesh::Mesh(){
	glGenVertexArrays(1, &VertexArrayObject);
	glBindVertexArray(VertexArrayObject);

	glGenBuffers(5, &VertexBuffer[0]);
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LVertexBuffer]);
}

Mesh::Mesh(Voxel v){
	// Here is a list of all the things that the shader needs to know from the program in order to render a singel voxel.
	/*
		Vertices (generated by the values that are stored in the array above)
		Normals (Also derived form the array defined above)
		Texture Coordinates (Always the same, always going to be 0-1 because the texutures will be stored in an array texture)
		Texture Number (this defines what type of block this will be. Defined per voxel.)
		Occlusion (This will be derived from a ray trace? need to find some way to figure out the proper occlusion values.)
		Color (defined per voxel.)

	*/
	glGenVertexArrays(1, &VertexArrayObject);
	glBindVertexArray(VertexArrayObject);

	glGenBuffers(5, &VertexBuffer[0]);
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LVertexBuffer]);

	GenerateMesh(v);
	UpdateMesh();
	//PrintMeshVerts();
}

Mesh::~Mesh(){
	glDeleteVertexArrays(1, &VertexArrayObject);
	glDeleteBuffers(5, &VertexBuffer[0]);
}

void Mesh::UpdateMesh(){
	glBindVertexArray(VertexArrayObject);
	//Initializing the vertex and normals for this particular mesh.
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LVertexBuffer]);
	glBufferData(GL_ARRAY_BUFFER, vertices.size()*sizeof(glm::vec4) + vertexNormals.size()*sizeof(glm::vec4),nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size()*sizeof(glm::vec4), vertices.data());
	glBufferSubData(GL_ARRAY_BUFFER, vertices.size()*sizeof(glm::vec4), vertexNormals.size()*sizeof(glm::vec4), vertexNormals.data());

	shaderPositions.emplace_back(GLuint());
	shaderPositions[0] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexPosition");
	glEnableVertexAttribArray(shaderPositions[0]);
	glVertexAttribPointer(shaderPositions[0], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	shaderPositions.emplace_back(GLuint());
	shaderPositions[1] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexNormal");
	glEnableVertexAttribArray(shaderPositions[1]);
	glVertexAttribPointer(shaderPositions[1], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(vertices.size() * sizeof(glm::vec4)));

	//Initializing the texture values for this mesh.
	// glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LTextureBuffer]);
	// glBufferData(GL_ARRAY_BUFFER, textureCoords.size()*sizeof(glm::vec2), nullptr, GL_DYNAMIC_DRAW);
	// glBufferSubData(GL_ARRAY_BUFFER, 0, textureCoords.size()*sizeof(glm::vec2), textureCoords.data());

	// shaderPositions.emplace_back();
	// shaderPositions[2] = glGetAttribLocation(ShaderController.getProgramVariable(), "TextureCoords");
	// glEnableVertexAttribArray(shaderPositions[2]);
	// glVertexAttribPointer(shaderPositions[2], 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	//Initializing the Color values for each vertex of this mesh
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LColorArray]);
	glBufferData(GL_ARRAY_BUFFER, colors.size()*sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, colors.size()*sizeof(glm::vec3), colors.data());

	shaderPositions.emplace_back(GLuint());

	shaderPositions.emplace_back(GLuint());
	shaderPositions[3] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexColor");
	glEnableVertexAttribArray(shaderPositions[3]);
	glVertexAttribPointer(shaderPositions[3], 3, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	//Initialize which texture will be utilized for this particular Side.
	
	//Initialize the Model matrices / Will I even need this? Or can this be passed in as a uniform for this particular Mesh?
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LModelMatrices]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4), nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(glm::mat4), &modelMatrix);
/*	for(int i=0; i<modelMatrices.size(); i++){
		print4x4Matrix(modelMatrices[i]);
	}*/

	shaderPositions.emplace_back(GLuint());
	shaderPositions[4] = glGetAttribLocation(ShaderController.getProgramVariable(), "modelMatrix");
    glEnableVertexAttribArray(shaderPositions[4]); 
    glVertexAttribPointer(shaderPositions[4], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
    glEnableVertexAttribArray(shaderPositions[4]+1); 
    glVertexAttribPointer(shaderPositions[4]+1, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET((sizeof(glm::vec4))));
    glEnableVertexAttribArray(shaderPositions[4]+2); 
    glVertexAttribPointer(shaderPositions[4]+2, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET((sizeof(glm::vec4)*2)));
    glEnableVertexAttribArray(shaderPositions[4]+3); 
    glVertexAttribPointer(shaderPositions[4]+3, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET((sizeof(glm::vec4)*3)));
    glVertexAttribDivisor(shaderPositions[4], 1);
    glVertexAttribDivisor(shaderPositions[4]+1, 1);
    glVertexAttribDivisor(shaderPositions[4]+2, 1);
    glVertexAttribDivisor(shaderPositions[4]+3, 1);

    //Passing the brightness into the shader below
    glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LBrightnessBuffer]);
	glBufferData(GL_ARRAY_BUFFER, brightness.size()*sizeof(float), nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, brightness.size()*sizeof(float), brightness.data());

	shaderPositions.emplace_back(GLuint());
	shaderPositions[5] = glGetAttribLocation(ShaderController.getProgramVariable(), "brightness");
	glEnableVertexAttribArray(shaderPositions[5]);
	glVertexAttribPointer(shaderPositions[5], 1, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

}

void Mesh::GenerateMesh(Voxel v){
	for(int i=0; i<6; i++){
		if(v.getActiveSide()[i] == true){
			GenerateCubeSide((CubeFace)i,v.getBrightness(i), v.getColor(), v.getPosition());
		}
	}	
	//Here I need to reorganize and instance-tize the vertices i think.
}

void Mesh::GenerateCubeSide(CubeFace face, float b, VoxelColor c, glm::vec3 offset){
	switch(face){
		case RightFace:
			addVertexToMesh(CubeVerts[TopFrontLeft]+offset);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[TopBackLeft]+offset);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomBackLeft]+offset);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackLeft]+offset);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomFrontLeft]+offset);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[TopFrontLeft]+offset);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addNormalTomesh(DirectionVectors[face]);
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		case LeftFace:
			addVertexToMesh(CubeVerts[TopBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[TopFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[TopFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		case TopFace:
			addVertexToMesh(CubeVerts[TopBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[TopBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[TopFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[TopFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[TopFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[TopBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		case BottomFace:
			addVertexToMesh(CubeVerts[BottomFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		case FrontFace:
			addVertexToMesh(CubeVerts[TopFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[TopFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomFrontLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[TopFrontRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		case BackFace:
			addVertexToMesh(CubeVerts[TopBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(CubeVerts[TopBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(CubeVerts[BottomBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackRight]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(CubeVerts[BottomBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(CubeVerts[TopBackLeft]+offset);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addBrightnessToMesh(b);
				addColorToMesh(c);
			}
			break;
		default:
			std::cerr << "INVALID SIDE GENERATION ATTEMPT." << std::endl;
			break;
	}
}

void Mesh::addVertexToMesh(glm::vec3 vert){
	glm::vec4 finalVertex(vert, 1.0f);
	vertices.emplace_back(finalVertex);
}

void Mesh::addNormalTomesh(glm::vec3 norm){
	glm::vec4 finalNormal(norm, 0.0f);
	vertexNormals.emplace_back(finalNormal);
}

void Mesh::addTexCoordToMesh(glm::vec2 tex){
	textureCoords.emplace_back(tex);
}

void Mesh::addColorToMesh(VoxelColor c){
	colors.emplace_back(BlockColors[c]);
}

void Mesh::addMMToMesh(glm::mat4 mm){
	modelMatrix = mm;
}

void Mesh::addBrightnessToMesh(float b){
	brightness.emplace_back(b);
}

void Mesh::mergeWithMesh(Mesh * m){
	std::vector<glm::vec4> tempVerts = m->getVerts();
	this->vertices.insert(this->vertices.end(), tempVerts.begin(), tempVerts.end());
	std::vector<glm::vec4> tempVertNorms = m->getVertNormals();
	this->vertexNormals.insert(this->vertexNormals.end(), tempVertNorms.begin(), tempVertNorms.end());
	std::vector<glm::vec2> tempTexCoords = m->getTexCoords();
	this->textureCoords.insert(this->textureCoords.end(), tempTexCoords.begin(), tempTexCoords.end());
	std::vector<glm::vec3> tempColors = m->getColors();
	this->colors.insert(this->colors.end(), tempColors.begin(), tempColors.end());
	glm::mat4 tempMatrix = m->getMatrix();
	this->modelMatrix = tempMatrix;
	std::vector<float> tempBright = m->getBrightness();
	this->brightness.insert(this->brightness.end(), tempBright.begin(), tempBright.end());
}

void Mesh::PrintMeshVerts(){
	std::cerr << "verts Size:" << vertices.size() << std::endl;
	std::cerr << "Colors Size:" << colors.size() << std::endl;
	std::cerr << "Normals Size:" << vertexNormals.size() << std::endl;
	std::cerr << "Texture coords Size:" << textureCoords.size() << std::endl;
	for(int i=0; i<vertices.size(); i++){
		std::cerr << "\tVertex " << i << ": \nX: " << vertices[i].x << "\nY: " << vertices[i].y << "\nZ: " << vertices[i].z << std::endl;
	}	
}

void Mesh::drawMesh(){
	//PrintMeshVerts();
	glBindVertexArray(VertexArrayObject);
	glDrawArrays(GL_TRIANGLES, 0, vertices.size());
	glGetError();
}

std::vector<glm::vec4> Mesh::getVerts(){
	return vertices;
}

std::vector<glm::vec4> Mesh::getVertNormals(){
	return vertexNormals;
}

std::vector<glm::vec2> Mesh::getTexCoords(){
	return textureCoords;
}

std::vector<glm::vec3> Mesh::getColors(){
	return colors;
}

std::vector<GLuint> Mesh::getIndices(){
	return indices;
}

glm::mat4 Mesh::getMatrix(){
	return modelMatrix;
}

std::vector<float> Mesh::getBrightness(){
	return brightness;
}

RenderController::RenderController(){
	projectionMatrix = glm::perspective(PI/2.25f, ((float)SCREENWIDTH)/SCREENHEIGHT, 0.01f, 100.0f);
	viewMatrix = glm::lookAt(glm::vec3(-10.0f, 20.0f, 0.0f), glm::vec3(8.0f,8.0f,8.0f), glm::vec3(0.0f,1.0f,0.0f));
}

RenderController::~RenderController(){

}

std::string RenderController::getVertexShaderPath(){
	return vertexShaderPath;
}

void RenderController::setVertexShaderPath(std::string path){
	vertexShaderPath = path;
}

std::string RenderController::getFragmentShaderPath(){
	return fragmentShaderPath;
}

void RenderController::setFragmentShaderPath(std::string path){
	fragmentShaderPath = path;
}

GLuint RenderController::getProgramVariable(){
	return programVariable;
}

void RenderController::setProgramVariable(GLuint prog){
	programVariable = prog;
}

// Create a GLSL program object from vertex and fragment shader files
void RenderController::createShaderProgram(){
    GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fragShader = glCreateShader(GL_FRAGMENT_SHADER);

    // Read shaders
    std::string vertShaderStr = readFileToString(vertexShaderPath.c_str());
    std::string fragShaderStr = readFileToString(fragmentShaderPath.c_str());

    const char *vertShaderSrc = vertShaderStr.c_str();
    const char *fragShaderSrc = fragShaderStr.c_str();

    GLint result = GL_FALSE;
    int logLength;

    // Compile vertex shader
   	if(DEBUGMODE)std::cerr << "Compiling vertex shader." << std::endl;
    glShaderSource(vertShader, 1, &vertShaderSrc, nullptr);
    glCompileShader(vertShader);

    // Check vertex shader
    glGetShaderiv(vertShader, GL_COMPILE_STATUS, &result);
    glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> vertShaderError((logLength > 1) ? logLength : 1);
    glGetShaderInfoLog(vertShader, logLength, nullptr, &vertShaderError[0]);
    if(logLength > 1) std::cerr << "vert Errors: " << &vertShaderError[0] << std::endl;

    // Compile fragment shader
    if(DEBUGMODE)std::cerr << "Compiling fragment shader." << std::endl;
    glShaderSource(fragShader, 1, &fragShaderSrc, nullptr);
    glCompileShader(fragShader);

    // Check fragment shader
    glGetShaderiv(fragShader, GL_COMPILE_STATUS, &result);
    glGetShaderiv(fragShader, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> fragShaderError((logLength > 1) ? logLength : 1);
    glGetShaderInfoLog(fragShader, logLength, nullptr, &fragShaderError[0]);
    if(logLength > 1) std::cerr << "Frag Errors: " << &fragShaderError[0] << std::endl;

    std::cerr << "Linking program" << std::endl;
    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    glGetProgramiv(program, GL_LINK_STATUS, &result);
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> programError( (logLength > 1) ? logLength : 1 );
    glGetProgramInfoLog(program, logLength, nullptr, &programError[0]);
    if(logLength > 1) std::cerr << "Prog Errors: " <<&programError[0] << std::endl;

    glDeleteShader(vertShader);
    glDeleteShader(fragShader);
    glUseProgram(program);
    programVariable = program;
    glUniformMatrix4fv(glGetUniformLocation(ShaderController.getProgramVariable(), "projectionMatrix"), 1, GL_FALSE, &(projectionMatrix[0][0]));
	glUniformMatrix4fv(glGetUniformLocation(ShaderController.getProgramVariable(), "viewMatrix"), 1, GL_FALSE, &(viewMatrix[0][0]));
}