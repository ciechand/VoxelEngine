#include "../Headers/CryoMain.hpp"
#include "../Headers/CryoRenderer.hpp"
#include "../Headers/CryoUtil.hpp"

RenderController ShaderController;

VoxelColor GlobalColor = Red;

//const int BlockColors[16] = {0x000000, 0xff0000, 0x800000, 0xff0084, 0x9c00ff, 0x000080, 0x0000ff, 0x00baff, 0x00ffcc, 0x00ff30, 0x009900, 0x999900, 0xfcff00, 0xa56900, 0xffa200, 0xff8900};
const glm::vec3 BlockColors[16] = {glm::vec3(255.0f,255.0f,255.0f),glm::vec3(255.0f,0.0f,0.0f),glm::vec3(128.0f,0.0f,0.0f),
									glm::vec3(255.0f,119.0f,173.0f),glm::vec3(255.0f,0.0f,102.0f), glm::vec3(156.0f,0.0f,255.0f),
									glm::vec3(0.0f,0.0f,128.0f),glm::vec3(0.0f,0.0f,255.0f),glm::vec3(0.0f,186.0f,255.0f),
									glm::vec3(0.0f,255.0f,204.0f),glm::vec3(0.0f,255.0f,48.0f),glm::vec3(0.0f,153.0f,0.0f),
									glm::vec3(252.0f,255.0f,0.0f),glm::vec3(165.0f,105.0f,0.0f),glm::vec3(255.0f,204.0f,0.0f),
									glm::vec3(255.0f,137.0f,0.0f)};

//Const Global Array for the different vertexes of a cube. These Can be accessed with the enum CubeVertices.
const glm::vec3 CubeVerts[8] = {
glm::vec3(-HALFSIZE,HALFSIZE,-HALFSIZE),glm::vec3(HALFSIZE,HALFSIZE,-HALFSIZE),
glm::vec3(-HALFSIZE,HALFSIZE, HALFSIZE),glm::vec3(HALFSIZE,HALFSIZE,HALFSIZE),
glm::vec3(-HALFSIZE,-HALFSIZE,-HALFSIZE),glm::vec3(HALFSIZE,-HALFSIZE,-HALFSIZE),
glm::vec3(-HALFSIZE,-HALFSIZE,HALFSIZE),glm::vec3(HALFSIZE,-HALFSIZE,HALFSIZE)
};

//Const GlobaL array for the different directional vectors, these can be accessed with the CubeFace Enum.
const glm::vec3 DirectionVectors[6] = {
glm::vec3(-1.0,0.0,0.0), glm::vec3(1.0,0.0,0.0),
glm::vec3(0.0,1.0,0.0), glm::vec3(0.0,-1.0,0.0),
glm::vec3(0.0,0.0,1.0), glm::vec3(0.0,0.0,-1.0)
};

//Functions for the Voxel Class
Voxel::Voxel(){
	voxColor = Red;
	position = glm::vec3(0.0f, 0.0f, 0.0f);
}

Voxel::~Voxel(){

	
}

bool Voxel::getActive(){
	return voxActive;	
}

void Voxel::setActive(bool va){
	voxActive = va;
}

glm::vec3 Voxel::getPosition(){
	return position;
}

void Voxel::setPosition(glm::vec3 pos){
	position = pos;
}

bool Voxel::getActiveSide(unsigned int n){
	return activeSides[n];
}

std::vector<bool> Voxel::getActiveSide(){
	return activeSides;
}

void Voxel::setActiveSide(unsigned int n, bool s){
	activeSides[n] = s;
}

void Voxel::setActiveSide(std::vector<bool> s){
	activeSides = s;
}


VoxelColor Voxel::getColor(){
	return voxColor;
}

void Voxel::setColor(VoxelColor vc){
	voxColor = vc;
}

std::vector<unsigned char> Voxel::getBrightness(){
	return brightness;
}

unsigned char Voxel::getBrightness(unsigned int n){
	return brightness[n];
}

void Voxel::setBrightness(unsigned int n, unsigned char c){
	brightness[n] = c;
}

void Voxel::setBrightness(std::vector<unsigned char> s){
	brightness = s;
}

int Voxel::getVoxTex(){
	return voxTex;
}

void Voxel::setVoxTex(int t){
	voxTex = t;
}

Mesh::Mesh(Voxel v){
	// Here is a list of all the things that the shader needs to know from the program in order to render a singel voxel.
	/*
		Vertices (generated by the values that are stored in the array above)
		Normals (Also derived form the array defined above)
		Texture Coordinates (Always the same, always going to be 0-1 because the texutures will be stored in an array texture)
		Texture Number (this defines what type of block this will be. Defined per voxel.)
		Occlusion (This will be derived from a ray trace? need to find some way to figure out the proper occlusion values.)
		Color (defined per voxel.)

	*/
	glGenVertexArrays(1, &VertexArrayObject);
	glBindVertexArray(VertexArrayObject);

	glGenBuffers(3, &VertexBuffer[0]);
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LVertexBuffer]);

	GenerateMesh(v);
	UpdateMesh();
	PrintMeshVerts();
}

Mesh::~Mesh(){
	glDeleteVertexArrays(1, &VertexArrayObject);
	glDeleteBuffers(3, &VertexBuffer[0]);
}

void Mesh::UpdateMesh(){
	glBindVertexArray(VertexArrayObject);
	//Initializing the vertex and normals for this particular mesh.
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LVertexBuffer]);
	glBufferData(GL_ARRAY_BUFFER, vertices.size()*sizeof(glm::vec4) + vertexNormals.size()*sizeof(glm::vec4),nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size()*sizeof(glm::vec4), vertices.data());
	glBufferSubData(GL_ARRAY_BUFFER, vertices.size()*sizeof(glm::vec4), vertexNormals.size()*sizeof(glm::vec4), vertexNormals.data());

	shaderPositions.emplace_back();
	shaderPositions[0] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexPosition");
	glEnableVertexAttribArray(shaderPositions[0]);
	glVertexAttribPointer(shaderPositions[0], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	shaderPositions.emplace_back();
	shaderPositions[1] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexNormal");
	glEnableVertexAttribArray(shaderPositions[1]);
	glVertexAttribPointer(shaderPositions[1], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(vertices.size() * sizeof(glm::vec4)));

	//Initializing the texture values for this mesh.
	// glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LTextureBuffer]);
	// glBufferData(GL_ARRAY_BUFFER, textureCoords.size()*sizeof(glm::vec2), nullptr, GL_DYNAMIC_DRAW);
	// glBufferSubData(GL_ARRAY_BUFFER, 0, textureCoords.size()*sizeof(glm::vec2), textureCoords.data());

	// shaderPositions.emplace_back();
	// shaderPositions[2] = glGetAttribLocation(ShaderController.getProgramVariable(), "TextureCoords");
	// glEnableVertexAttribArray(shaderPositions[2]);
	// glVertexAttribPointer(shaderPositions[2], 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	//Initializing the Color values for each vertex of this mesh
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LColorArray]);
	glBufferData(GL_ARRAY_BUFFER, colors.size()*sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, colors.size()*sizeof(glm::vec3), colors.data());

	shaderPositions.emplace_back();
	shaderPositions.emplace_back();
	shaderPositions[3] = glGetAttribLocation(ShaderController.getProgramVariable(), "VertexColor");
	glEnableVertexAttribArray(shaderPositions[3]);
	glVertexAttribPointer(shaderPositions[3], 3, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));

	//Initialize which texture will be utilized for this particular Side.
	
	//Initialize the Model matrices / Will I even need this? Or can this be passed in as a uniform for this particular Mesh?
	// glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer[LModelMatrices]);
	// glBufferData(GL_ARRAY_BUFFER, /*Size betwen matrices*/, nullptr, GL_DYNAMIC_DRAW);
	// glBufferData(GL_ARRAY_BUFFER, 0, textureCoords.size()*sizeof(glm::vec2), textureCoords.data());

	// shaderPositions.emplace_back();
	// shaderPositions[3] = glGetAttribLocation(/*Shader pointer goes here*/, /*Name within shader will go here.*/);
 //    glEnableVertexAttribArray(shaderPositions[3]); 
 //    glVertexAttribPointer(shaderPositions[3], 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(listStartingAddress+0));
 //    glEnableVertexAttribArray(shaderPositions[3]+1); 
 //    glVertexAttribPointer(shaderPositions[3]+1, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(listStartingAddress+(vec4Size)));
 //    glEnableVertexAttribArray(shaderPositions[3]+2); 
 //    glVertexAttribPointer(shaderPositions[3]+2, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(listStartingAddress+(vec4Size*2)));
 //    glEnableVertexAttribArray(shaderPositions[3]+3); 
 //    glVertexAttribPointer(shaderPositions[3]+3, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(listStartingAddress+(vec4Size*3)));
 //    glVertexAttribDivisor(shaderPositions[3], 1);
 //    glVertexAttribDivisor(shaderPositions[3]+1, 1);
 //    glVertexAttribDivisor(shaderPositions[3]+2, 1);
 //    glVertexAttribDivisor(shaderPositions[3]+3, 1);
	 glm::mat4 projectionMatrix = glm::perspective(PI/2.25f, ((float)SCREENWIDTH)/SCREENHEIGHT, 0.01f, 100.0f);
	glUniformMatrix4fv(glGetUniformLocation(ShaderController.getProgramVariable(), "projectionMatrix"), 1, GL_FALSE, &(projectionMatrix[0][0]));
	glm::mat4 viewMatrix = glm::lookAt(glm::vec3(10.0f, 5.0f, 5.0f), glm::vec3(0.0f,0.0f,0.0f), glm::vec3(0.0f,1.0f,0.0f));
	glUniformMatrix4fv(glGetUniformLocation(ShaderController.getProgramVariable(), "viewMatrix"), 1, GL_FALSE, &(viewMatrix[0][0]));

}

void Mesh::GenerateMesh(Voxel v){
	for(int i=0; i<6; i++){
		if(v.getActiveSide()[i] == true){
			GenerateCubeSide((CubeFace)i,v.getPosition(), v.getColor());
		}
	}	
	//Here I need to reorganize and instance-tize the vertices i think.
}

void Mesh::GenerateCubeSide(CubeFace face, glm::vec3 offset, VoxelColor c){
	switch(face){
		case LeftFace:
			addVertexToMesh(offset+CubeVerts[TopFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		case RightFace:
			addVertexToMesh(offset+CubeVerts[TopBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		case TopFace:
			addVertexToMesh(offset+CubeVerts[TopBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		case BottomFace:
			addVertexToMesh(offset+CubeVerts[BottomFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		case FrontFace:
			addVertexToMesh(offset+CubeVerts[TopFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopFrontRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		case BackFace:
			addVertexToMesh(offset+CubeVerts[TopBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[TopBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,1.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackRight]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(0.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[BottomBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,0.0f));
			addVertexToMesh(offset+CubeVerts[TopBackLeft]);
			addNormalTomesh(DirectionVectors[face]);
			addTexCoordToMesh(glm::vec2(1.0f,1.0f));
			for(int i=0; i<6; i++){
				addColorToMesh(GlobalColor);
			}
			break;
		default:
			std::cerr << "INVALID SIDE GENERATION ATTEMPT." << std::endl;
			break;
	}
	GlobalColor = (VoxelColor)(GlobalColor+1);	
}

void Mesh::addVertexToMesh(glm::vec3 vert){
	glm::vec4 finalVertex(vert, 1.0f);
	vertices.emplace_back(finalVertex);
}

void Mesh::addNormalTomesh(glm::vec3 norm){
	glm::vec4 finalNormal(norm, 0.0f);
	vertexNormals.emplace_back(finalNormal);
}

void Mesh::addTexCoordToMesh(glm::vec2 tex){
	textureCoords.emplace_back(tex);
}

void Mesh::addColorToMesh(VoxelColor c){
	colors.emplace_back(BlockColors[c]);
}

void Mesh::PrintMeshVerts(){
	std::cout << "verts Size:" << vertices.size() << std::endl;
	std::cout << "Colors Size:" << colors.size() << std::endl;
	std::cout << "Normals Size:" << vertexNormals.size() << std::endl;
	std::cout << "Texture coords Size:" << textureCoords.size() << std::endl;
	for(int i=0; i<vertices.size(); i++){
		std::cout << "\tVertex " << i << ": \nX: " << vertices[i].x << "\nY: " << vertices[i].y << "\nZ: " << vertices[i].z << std::endl;
	}	
}

void Mesh::drawMesh(){
	glBindVertexArray(VertexArrayObject);
	glDrawArrays(GL_TRIANGLES, 0, vertices.size());
	glGetError();
}

RenderController::RenderController(){

}

RenderController::~RenderController(){

}

std::string RenderController::getVertexShaderPath(){
	return vertexShaderPath;
}

void RenderController::setVertexShaderPath(std::string path){
	vertexShaderPath = path;
}

std::string RenderController::getFragmentShaderPath(){
	return fragmentShaderPath;
}

void RenderController::setFragmentShaderPath(std::string path){
	fragmentShaderPath = path;
}

GLuint RenderController::getProgramVariable(){
	return programVariable;
}

void RenderController::setProgramVariable(GLuint prog){
	programVariable = prog;
}

// Create a GLSL program object from vertex and fragment shader files
void RenderController::createShaderProgram(){
    GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fragShader = glCreateShader(GL_FRAGMENT_SHADER);

    // Read shaders
    std::string vertShaderStr = readFileToString(vertexShaderPath.c_str());
    std::string fragShaderStr = readFileToString(fragmentShaderPath.c_str());

    const char *vertShaderSrc = vertShaderStr.c_str();
    const char *fragShaderSrc = fragShaderStr.c_str();

    GLint result = GL_FALSE;
    int logLength;

    // Compile vertex shader
   	if(DEBUGMODE)std::cerr << "Compiling vertex shader." << std::endl;
    glShaderSource(vertShader, 1, &vertShaderSrc, nullptr);
    glCompileShader(vertShader);

    // Check vertex shader
    glGetShaderiv(vertShader, GL_COMPILE_STATUS, &result);
    glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> vertShaderError((logLength > 1) ? logLength : 1);
    glGetShaderInfoLog(vertShader, logLength, nullptr, &vertShaderError[0]);
    if(logLength > 1) std::cerr << "vert Errors: " << &vertShaderError[0] << std::endl;

    // Compile fragment shader
    if(DEBUGMODE)std::cerr << "Compiling fragment shader." << std::endl;
    glShaderSource(fragShader, 1, &fragShaderSrc, nullptr);
    glCompileShader(fragShader);

    // Check fragment shader
    glGetShaderiv(fragShader, GL_COMPILE_STATUS, &result);
    glGetShaderiv(fragShader, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> fragShaderError((logLength > 1) ? logLength : 1);
    glGetShaderInfoLog(fragShader, logLength, nullptr, &fragShaderError[0]);
    if(logLength > 1) std::cerr << "Frag Errors: " << &fragShaderError[0] << std::endl;

    std::cerr << "Linking program" << std::endl;
    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    glGetProgramiv(program, GL_LINK_STATUS, &result);
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);
    std::vector<char> programError( (logLength > 1) ? logLength : 1 );
    glGetProgramInfoLog(program, logLength, nullptr, &programError[0]);
    if(logLength > 1) std::cerr << "Prog Errors: " <<&programError[0] << std::endl;

    glDeleteShader(vertShader);
    glDeleteShader(fragShader);
    glUseProgram(program);
    programVariable = program;
}